title: Введение (MoonScript)
--
<div class="override_lang"></div>

# Введение (MoonScript)

## Создаем базовое приложение

Чтобы создать в текущей папке новый проект Lapis на MoonScript,
наберите следующую команду:

```bash
$ lapis new
```

Теперь у нас есть стандартный `nginx.conf` и костяк приложения `app.moon`:

```moon
-- app.moon
lapis = require "lapis"

class extends lapis.Application
  "/": =>
    "Welcome to Lapis #{require "lapis.version"}!"
]]
```

Здесь определеляется обычный модуль Lua, который возвращает
класс приложения. (В MoonScript работает неявный возврат последней
инструкции.)

> Не забывайте компилировать файлы `.moon`, когда создаёте
> или изменяете их. Чтобы отслеживать изменения файлов в текущей папке
> и компилировать автоматически, запустите `moonc -w`.

Запустим наш сервер:

```bash
lapis server
```

Если скомпилировали файл `.moon`, тогда наша страница будет
доступна на <http://localhost:8080>.

Члены приложения соответствуют паттернам, с которыми сопоставляются
входящие запросы. Здесь мы имеем дело с так называемыми `путями` и
`обработчиками`, где путь - это паттерн, а обработчик - это функция,
которая обрабатывает соответствующий путь.
В этом примере путь `"/"` соответствует обработчику, который
выводит `"Hello World!"`

Значение, возвращаемое обработчиком, определяет, что попадёт в ответ.
В простейшем случае возвращается строка, которая и пишется в ответ.

> Подробнее о путях и обработчиках написано в разделе [Пути и
> Обработчики][2] guide.

## Приложения Lapis

Когда мы употребляем термин `приложение Lapis`, мы имеем в виду
класс, унаследованный от `lapis.Application`.
Свойства приложения составляют пути, которые обслуживает
приложение, и обработчики, которые оно запускает.

Если имя свойства является строкой и начинается с `"/"` или
свойство является таблицей, то оно определяет путь.
Остальные свойства являются методами приложения.

### Параметры запроса

Пути могут "захватывать" значения, которые помещаются
в параметры запроса.

Именованные параметры состоят из двоетоция (`:`), после которого
записывается имя параметра.
Они соответствуют всем символам, кроме `/`.

```moon
class extends lapis.Application
  "/user/:name": => "Hello #{@params.name}"
```

Если бы мы открыли путь `"/user/leaf"`, то `@params.name` было
бы равно `"leaf"`.

В `@params` хранятся все параметры обработчика. Это сборная
солянка из параметров URL, GET и POST.

Звёздочка (`*`) захватывает все символы и не имеет имени.
Значение, захваченное звёздочкой, помещается в `@params.splat`.

```moon
"/things/*": => "Rest of the url: #{@params.splat}"
```

> Подробнее о том, откуда берутся параметры, читайте в
> разделе [Объект-запрос][3].

### Обработчик

Обработчик - это функция, которая вызывается, когда
соответствующий ей путь приложения совпадает с путём запроса.
Обработчики пишутся с жирными стрелками (`=>`), так что
можно подумать, что в `self` передаётся экземпляр приложения,
но на самом деле это экземпляр класса `Request`,
представляющего запрос.

Мы уже видели, что все параметры запроса хранятся в `@params`.

Чтобы получить параметры разного происхождения по отдельности,
используются `@GET`, `@POST`, и `@url_params`.

Экземпляр приложения можно получить через `@app`, а запрос и ответ
через `@req` and `@res`.

Объект `@app` надо рассматривать как объект только для чтения,
так как он используется несколькими запросами.

> Подробнее про объект-запрос читайте в
> разделе [Объект-запрос][3].

### Именованные пути

Полезно давать имена путям, чтобы генерировать URL по этим
именам, а не зашивать URL в ссылках с других старниц.

Если путь обработчика является таблицей с единственной
парой ключ-значение, то эта пара воспринимается как
имя и путь паттерна.
MoonScript предоставляет удобный синтаксис для этого:

```moon
class extends lapis.Application
  [index: "/"]: =>
    @url_for "user_profile", name: "leaf"

  [user_profile: "/user/:name"]: =>
    "Hello #{@params.name}, go home: #{@url_for "index"}"
```

Пути различных обработчиков можно генерировать при помощи
`@url_for`. Первый аргумент - имя пути, а второй дополнительный
аргумент - таблица значений, которые подставляются в именованные
пареметры пути.

### Предобработчики

Бывает нужно выполнять какие-то действия перед каждым запросом.
К примеру, открыть пользовательскую сессию.
Для этого надо задать предобработчик, то есть функцию, которая
запускается перед каждым обработчиком:

```moon
lapis = require "lapis"

class App extends lapis.Application
  @before_filter =>
    if @session.user
      @current_user = load_user @session.user

  "/": =>
    "current user is: #{@current_user}"
```

Можно задать несколько предобработчков, для этого нужно
вызвать `@before_filter` несколько раз.
Множественные предобработчики запускаются в том порядке,
в котором их добавили.

Если предобработчик вызывает метод `@write`, то обработчик
отменяется.
Например, мы можем отменить обработчик и перенаправить
пользователя на другую страницу, если какое-то условие
не выполняется:

```moon
lapis = require "lapis"

class App extends lapis.Application
  @before_filter =>
    unless user_meets_requirements!
      @write redirect_to: @url_for "login"

  "/": =>
    "Welcome to the page"
```

> Результат обработчика также подаётся в `@write`,
> так что в него можно подавать всё то, что можно вернуть
> из обработчика

### Обработка методов HTTP

Часто обработчик одного пути делает разные вещи
в зависимости от метода HTTP.
В Lapis есть функции-помощники, которые упрощают
написание таких обработчиков.
Функция `respond_to` принимает таблицу, переводящую метод
HTTP в функцию, которая выполняется для запросов
с этим методом HTTP.

```moon
lapis = require "lapis"
import respond_to from require "lapis.application"

class App extends lapis.Application
  [create_account: "/create_account"]: respond_to {
    GET: => render: true

    POST: =>
      create_user @params
      redirect_to: @url_for "index"
  }
```

В `respond_to` можно также прописать предобработчик, который
вызывается до обработчика метода HTTP.
Для этого в таблице нужно указать функцию с ключом `before`.
Здесь применяется та же логика, что в
[предобработчиках](#lapis-applications-before-filters),
так что можно вызвать `@write` и сам обработчик отменится.

```moon
lapis = require "lapis"

class App extends lapis.Application
  "/edit_user/:id": respond_to {
    before: =>
      @user = Users\find @params.id
      @write status: 404, "Not Found" unless @user

    GET: =>
      "Welcome " .. @user.name

    POST: =>
      @user\update @params.user
      redirect_to: @url_for "index"
  }

```

### Подприложения

По мере усложнения приложения, полезно разбить его на несколько
подприложений. Lapis не предписывает правил деления на
подприложения, но облегчает соединение приложений.

#### `@include(other_application, [opts])`

Допустим, у нас есть отдельное приложение для
обработки пользователей.

```moon
-- applications/users.moon
lapis = require "lapis"

class UsersApplication extends lapis.Application
  [login: "/login"]: do_login!
  [logout: "/logout"]: do_logout!
```

Подключим это приложение к основному приложению:

```moon
-- app.moon
lapis = require "lapis"

class extends lapis.Application
  @include "applications.users"

  [index: "/"]: =>
    @html ->
      a href: @url_for("login"), "Log in"
```

В этом примере `applications/user.moon` - это модуль, который
возвращает подприложение. Метод `include`
(метод класса `Application`) загружает это приложение в
наше корневое приложение. Метод `include` копирует все пути
в другое приложение, не изменяя их в исходном приложении.

Подприложения могут иметь предобработчики, которые выполняются
только для обработчиков, пришедших из подприложения.

Класс подприложения может содержать специальные поля `path`
и `name`:

* `path` -- префикс, добавляемый к паттернам копируемых путей
* `name` -- префикс, добавляемый к именам копируемых путей

```moon
class UsersApplication extends lapis.Application
  @path: "/users"
  @name: "user_"

  -- etc...
```

У `include` есть дополнительный второй аргумент, таблица опций.
Эти опции определяют или переопределяют значения полей
`path` и `name`:

Давайте добавим следующие префиксы приложению `UsersApplication`:

```moon
class extends lapis.Application
  @include "applications.users", path: "/users", name: "user_"

  "/": =>
    @url_for("user_login") -- returns "/users/login"
```

### Методы класса

#### `@find_action(action_name)`

Возвращает функцию-обработчик по имени.

[1]: http://moonscript.org/reference/#moonc
[2]: $root/reference/actions.html
[3]: $root/reference/actions.html#request-object
