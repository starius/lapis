title: Введение (MoonScript)
--
<div class="override_lang"></div>

# Введение (MoonScript)

## Создаем базовое приложение

Чтобы создать в текущей папке новый проект Lapis на MoonScript,
наберите следующую команду:

```bash
$ lapis new
```

Теперь у нас есть стандартный `nginx.conf` и костяк приложения `app.moon`:

```moon
-- app.moon
lapis = require "lapis"

class extends lapis.Application
  "/": =>
    "Welcome to Lapis #{require "lapis.version"}!"
]]
```

Здесь определеляется обычный модуль Lua, который возвращает
класс приложения. (В MoonScript работает неявный возврат последней
инструкции.)

> Не забывайте компилировать файлы `.moon`, когда создаёте
> или изменяете их. Чтобы отслеживать изменения файлов в текущей папке
> и компилировать автоматически, запустите `moonc -w`.

Запустим наш сервер:

```bash
lapis server
```

Если скомпилировали файл `.moon`, тогда наша страница будет
доступна на <http://localhost:8080>.

Члены приложения соответствуют паттернам, с которыми сопоставляются
входящие запросы. Здесь мы имеем дело с так называемыми `путями` и
`обработчиками`, где путь - это паттерн, а обработчик - это функция,
которая обрабатывает соответствующий путь.
В этом примере путь `"/"` соответствует обработчику, который
выводит `"Hello World!"`

Значение, возвращаемое обработчиком, определяет, что попадёт в ответ.
В простейшем случае возвращается строка, которая и пишется в ответ.

> Подробнее о путях и обработчиках написано в разделе [Пути и
> Обработчики][2] guide.

## Приложения Lapis

Когда мы употребляем термин `приложение Lapis`, мы имеем в виду
класс, унаследованный от `lapis.Application`.
Свойства приложения составляют пути, которые обслуживает
приложение, и обработчики, которые оно запускает.

Если имя свойства является строкой и начинается с `"/"` или
свойство является таблицей, то оно определяет путь.
Остальные свойства являются методами приложения.

### Параметры запроса

Пути могут "захватывать" значения, которые помещаются
в параметры запроса.

Именованные параметры состоят из двоетоция (`:`), после которого
записывается имя параметра.
Они соответствуют всем символам, кроме `/`.

```moon
class extends lapis.Application
  "/user/:name": => "Hello #{@params.name}"
```

Если бы мы открыли путь `"/user/leaf"`, то `@params.name` было
бы равно `"leaf"`.

В `@params` хранятся все параметры обработчика. Это сборная
солянка из параметров URL, GET и POST.

Звёздочка (`*`) захватывает все символы и не имеет имени.
Значение, захваченное звёздочкой, помещается в `@params.splat`.

```moon
"/things/*": => "Rest of the url: #{@params.splat}"
```

> Подробнее о том, откуда берутся параметры, читайте в
> разделе [Объект-запрос][3].

### Обработчик

Обработчик - это функция, которая вызывается, когда
соответствующий ей путь приложения совпадает с путём запроса.
Обработчики пишутся с жирными стрелками (`=>`), так что
можно подумать, что в `self` передаётся экземпляр приложения,
но на самом деле это экземпляр класса `Request`,
представляющего запрос.

Мы уже видели, что все параметры запроса хранятся в `@params`.

Чтобы получить параметры разного происхождения по отдельности,
используются `@GET`, `@POST`, и `@url_params`.

Экземпляр приложения можно получить через `@app`, а запрос и ответ
через `@req` and `@res`.

Объект `@app` надо рассматривать как объект только для чтения,
так как он используется несколькими запросами.

> Подробнее про объект-запрос читайте в
> разделе [Объект-запрос][3].


### Подприложения

По мере усложнения приложения, полезно разбить его на несколько
подприложений. Lapis не предписывает правил деления на
подприложения, но облегчает соединение приложений.

#### `@include(other_application, [opts])`

Допустим, у нас есть отдельное приложение для
обработки пользователей.

```moon
-- applications/users.moon
lapis = require "lapis"

class UsersApplication extends lapis.Application
  [login: "/login"]: do_login!
  [logout: "/logout"]: do_logout!
```

Подключим это приложение к основному приложению:

```moon
-- app.moon
lapis = require "lapis"

class extends lapis.Application
  @include "applications.users"

  [index: "/"]: =>
    @html ->
      a href: @url_for("login"), "Log in"
```

В этом примере `applications/user.moon` - это модуль, который
возвращает подприложение. Метод `include`
(метод класса `Application`) загружает это приложение в
наше корневое приложение. Метод `include` копирует все пути
в другое приложение, не изменяя их в исходном приложении.

Подприложения могут иметь предобработчики, которые выполняются
только для обработчиков, пришедших из подприложения.

Класс подприложения может содержать специальные поля `path`
и `name`:

* `path` -- префикс, добавляемый к паттернам копируемых путей
* `name` -- префикс, добавляемый к именам копируемых путей

```moon
class UsersApplication extends lapis.Application
  @path: "/users"
  @name: "user_"

  -- etc...
```

У `include` есть дополнительный второй аргумент, таблица опций.
Эти опции определяют или переопределяют значения полей
`path` и `name`:

Давайте добавим следующие префиксы приложению `UsersApplication`:

```moon
class extends lapis.Application
  @include "applications.users", path: "/users", name: "user_"

  "/": =>
    @url_for("user_login") -- returns "/users/login"
```

### Методы класса

#### `@find_action(action_name)`

Возвращает функцию-обработчик по имени.

[1]: http://moonscript.org/reference/#moonc
[2]: $root/reference/actions.html
[3]: $root/reference/actions.html#request-object
